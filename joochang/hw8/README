600.233 Computer Systems Fundamentals
Name: Joo Chang Lee
JHED ID: jlee381
Email: jlee381@jhu.edu
Assignment 8. Welcome to x86!
README


1.
Using C compiler to learn x86.

We will assume that we know about Makefile.

Here is a short description of how a c code actually gets compiled.
When a c source code is compiled, it first goes into a c preprocessor.
Here the code removes all # related codes.
For example, if there was #include, it will import the library.
if there was #define,
the c preprocessor will replace codes with actual values.
After this, the c preprocessor creates .i file.
Then this .i file gets into a compiler, and becomes a assembly language.
This is in .s file.
The .s file created then goes into an assembler,
creating machine code, .o file.
After that, the linker links all the .o files,
and finally creates the executable file.

In the Makefile, on CFLAGS, add -save-temps.
This will keep the .i, .s, and .o files created during compilation.
You may also want to add -O0, which means no optimization.
When you add optimization into your c compiler,
the assembly code may be neat,
but it may hide some underlying operations going in assembly language.

And then, if you are using a 64bit machine,
but looking for a 32bit code,
you may want to add -m32 as well.
In this case, also add -m32 into LDFLAGS and ASFLAGS,
since linker and assembler needs to know that
the code is for 32bit machine as well.

To summarize, in your Makefile,
have:
CFLAGS=-std=c99 -O0 -save-temps -m32
LDFLAGS=-m32
ASFLAGS=-m32
you can also use -std=c11.

After that, you can open the .s file created,
and look at the assembly language for that particular c program.


Now, to the actual instructions.
We will assume AT&T syntax here.

Integer operations

First of all, all operations involve values in registers.
This is done by moving values into registers.

The instruction is:
movl	src, dest
where movl is a move instruction for 32bit data.

for example, if you want to move a number 6 to eax register,
it would be
movl	$6, %eax
where $ stands for immediate value
and % stands for register notation.

likewise, if you want to move contents of a register to another register, 
it will be
movl	%edx, %eax.
which is moving contents of edx register to eax register.


Addition, subtraction, and multiplication.
(a + b, a - b, a * b)

First, we move a and b to registers.
movl	$a, %eax
movl	$b, %edx

Then, we do the operation.
For addition, we use
addl	%edx, %eax
which will add value of edx register into eax register.
The result will be stored in eax register.

For subtraction, we use
subl	%edx, %eax
which will subtract value of edx register from eax register.
The result will be stored in eax register.

For multiplication, we use
imull	%edx, %eax
which will multiply value of edx register to eax register.
The result will be stored in eax register.

Division and Remainder. (a / b, a % b)

First, we move a and b to registers.
movl	$a, %eax
movl	$b, %ecx
note that we used ecx this time, a different register from edx.

then we use cltd command which is:
cltd
which connecting two registers edx and eax
to represent a 64bit register as edx:eax
edx will be the more significant 32 bits
and eax will be the less significant 32 bits.

Then we call the divide instruction:
idiv	%ecx
which will divide the value of ecx (which is b)
from value of edx:eax 64-bit pseudo-register, which is a.
The result is stored in edx:eax register,
where the quotient is stored in %eax
and the remainder is stored in %edx.

Bitwise AND, OR and XOR:
(a & b, a | b, a ^ b)

First, we move a and b to registers.
movl	$a, %eax
movl	$b, %ecx

Then, we do the operation.
For AND operation, we use
andl	%edx, %eax
which will call a bitwise AND of the values in edx and eax registers.
The result will be stored in eax register.

For AND operation, we use
orl	%edx, %eax
which will compute a bitwise OR of the values in edx and eax registers.
The result will be stored in eax register.

For XOR operation, we use
xorl	%edx, %eax
which will compute a bitwise XOR of the values in edx and eax registers.
The result will be stored in eax register.

Bitwise NOT: (~a)

First, we move a to a register.
movl	$a, %eax

Then we compute bitwise NOT operation on eax register.
notl	%eax
the result is in %eax.
(Note that, if value in eax register is a positive integer,
the result of not operation is -a + 1,
and if the value is negative, the result is -a - 1.
This is caused by two's complement.)



Arrays:

(global array)
A global array is declared as .globl
which means that each symbol in the list is global.

So, if we have an integer array of size 10, holding numbers from 1 to 10,
we will have something like:

	.globl	array
array:
	.long	1		< array[0], the index address.
	.long	2
	.long	3
	.long	4
	.long	5
	.long	6
	.long	7
	.long	8
	.long	9
	.long	10

And it will look like this in memory:
-------------------------
			|	
-------------------------
	10		|	< array + 36
	9		|	< array + 32
	8		|	< array + 28
	7		|	< array + 24
	6		|	< array + 20
	5		|	< array + 16
	4		|	< array + 12
	3		|	< array + 8
	2		|	< array + 4
	1		|	< array
-------------------------
			|
-------------------------

When we access it,
we call the value by offset the first element in the array.
For example, if you are writing integer 7 to 5th element in the array
it will be:
movl	$7, array+16
where 16 is (5-1) * 4
And if you are calling the third element into %eax, it will be:
movl	array+8, %eax

And when we pass global array into function,
it pushes the immediate value of address into stack
and calls the function.

So, if we have bubble(array, NELEM)
we would have a stack like:

-------------------------
|			|
-------------------------				...
|	NELEM		|				3
-------------------------				2
|	array	------- | ------------------------->	1
-------------------------
|			|  < %esp
-------------------------
|			|
-------------------------

(assuming we have not pushed %ebp)

where the parameter is an address to the first element of the array.
When we call elements in the array,
we get the address of the first element, add it by offset,
and wrap it for an indirect call.
So, if we are moving the third element in global array into %eax,
we use:
	movl	-4(%esp), %eax
	addl	$8, %eax
	movl	(%eax), %eax

And when we are writing an integer 3 to fifth element in array,
it will be:
	movl	-4(%esp), %eax
	addl	$16, %eax
	movl	$3, (%eax)


Structs:

(global struct)
Struct is declared as a common symbol (.comm)
with size as everything included in struct added together.
ex) if a struct is

struct sample {
	int first;
	int second;
	int third;
	int fourth;
	char char1;
	char char2;
	char char3;
	char char4;
};

and initialized
struct sample structName;

it will appear as:
.comm structName, 20, 4

meaning that structName is stored in memory
as symbol with size 20 and alignment 4
(alignment means starting address will be a multiple of it,
in this case multiples of 4)
like:

-------------------------
			|
-------------------------
	char4		|	< structName + 19
	char3		|	< structName + 18
	char2		|	< structName + 17
	char1		|	< structName + 16
	fourth		|	< structName + 12
	third		|	< structName + 8
	second		|	< structName + 4
	first		|	< structName
-------------------------
			|
-------------------------

When you access it,
you call the value by offset the first position in the struct.
For example, if you are writing integer 7 to second integer,
it will be:
movl	$7, structName+4
And if you are calling the second integer to %eax, it will be:
movl	structName+4, %eax


(local struct)
Structs are stored as a whole local variable
stored in stack by subtracting stack pointer
(in multiples of 16)
- creating discrepancy between %esp and %ebp
(%ebp being higher)
elements defined first will be closer to %esp
and those defined last will be closer to %ebp.

So, for the last example, it will look like this in the stack:
-------------------------
			|	< %ebp
-------------------------
	char4		|	< %ebp - 1
	char3		|	< %ebp - 2
	char2		|	< %ebp - 3
	char1		|	< %ebp - 4
	fourth		|	< %ebp - 8
	third		|	< %ebp - 12
	second		|	< %ebp - 16
	first		|	< %ebp - 20	< %esp
-------------------------
			|
-------------------------

When you access it, you call the value by offset from ebp.
For example, if you are writing integer 7 to second integer,
it will be:
movl	$7, -16(%ebp)
And if you are calling the second integer to %eax, it will be:
movl	-16(%ebp), %eax



2.

min and max functions both take two parameters: a and b.
These are stored in stack,
so that at the point of entering the function,
a is at an address that is 4 higher than %esp,
and b is at an address that is 8 higher than %esp.

it will look like this:
-------------------------
|			|
-------------------------
|	b		|
-------------------------
|	a		|
-------------------------
|			|  < %esp
-------------------------
|			|
-------------------------

now you call a into %eax register.
After that, you call value from 8 higher than %esp (which is b)
and compare that to value %eax, which is a.
If a is greater, the EFLAGS register will be set.
(zero flag, sign flag, overflow flag used in this case)
Then, for min function, you move %edx to %eax if the %edx is greater
(zero flag not set, sign flag equal to overflow flag)
For max function, you move %edx to %eax if the %edx is smaller.
(zero flag not set, sign flag different from overflow flag)

Now the value in %eax will be the minimum(or maximum) of a or b,
depending on the function called.


3.

All notes commented in bubble.s
