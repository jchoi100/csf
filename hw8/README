600.233 Computer System Fundamentals
Assignment 8
Dodge the x86!
Name: Joon Hyuck Choi
JHED: jchoi100
email: jchoi100@jhu.edu
------------------------------------------------------------------------

========================================================================
Problem 1: Learning x86 Assembly
========================================================================
Welcome to a short x86 Tutorial!
In this tutorial, we will explain to you mainly three concepts in x86.

1) Functions
2) Local vs Global variables
3) Arrays

Let Start!

------------------------------------------------------------------------
1) Functions

Before we call a function, we must prepare the stack and registers for
use within the function. After the function is over, we must restore
the stack and registers to the state they were before it was called.

Moreover, before any type of procedure, we must push the original %ebp
into the stack and move the current %esp into the %ebp.

a. How functions access their parameters
	Before a function call, in the caller, we push the parameters to be 
	used into the stack in reverse order. For example, let's say we want
	to call function f on parameters a, b, c, d, e. (i.e. f(a,b,c,d,e))

	ex)
	The code looks like this (in somewhat pseudocode):
		caller:
			pushl %ebp
			movl  %esp, %ebp
			pushl %e
			pushl %d
			pushl %c
			pushl %b
			pushl %a
			call f
			(...)
		f:
			pushl %ebp
			movl  %esp, %ebp
			// Access saved parameters by using ebp offsets.
			// How to do so is explained below.
	Now, once in the callee function f, we can access the pushed args
	by using %ebp offsets. Remember how we pushed the %esp into %ebp?
	at 0(%ebp) lies %esp, at 4(%ebp) the return address to the caller.

	The arguments lie here:
		a:  8(%ebp)
		b: 12(%ebp)
		c: 16(%ebp)
		d: 20(%ebp)
		e: 24(%ebp)
	If there are more than 5 arguments, the offsets will go 28, 32 ...

b. How functions returns their results
	The result of a function is always assumed to be saved at %eax.
	It does not matter that intermediate computation results do not
	get saved at %eax, but the final result must be at %eax before
	we leave the function call.

	As an example, we show a short function that adds two numbers.
	(Note that not all the required contents are in this example.
	 We just show the necessary code to show an example of how 
	 function results are saved in the %eax register.)

	ex) 
		.text
		.globl plus
		.globl main
	plus:
		pushl %ebp                  # save the old ebp
		movl  %esp, %ebp			# put %esp into %ebp
		movl  8(%ebp), %edx			# get the 1st arg, 37, into %edx
		movl  12(%ebp), %eax		# get the 2nd arg, 10, into %eax
		addl  %edx, %eax			# %eax <- %eax + %edx
		popl  %ebp					# restore the old ebp
		ret 						# return
	main:
		pushl %ebp                  # save the old ebp
		movl  %esp, %ebp			# put %esp into %ebp
		pushl $10					# push second arg
		pushl $37					# push first arg
		call  plus					# call function plus
		addl  $8, %esp				# free up 37 and 10
		leave
		ret


	Using the previous example, we show what happens in the stack
	upto entering plus from main.

	      Stack
	|               |
	+---------------+
	| ra in startup |  <----- esp once entering main
	+---------------+
	|    old ebp    | 
	+---------------+
	|      10       |  <----- with pushl $10
	+---------------+
	|      37       |  <----- with pushl $37
	+---------------+
	|  ra in main   |  <----- esp once entering plus
	+---------------+
	|      ebp      |  <----- points to old ebp above
	+---------------+
	|               |
	+---------------+
	|               |


	Now, we show step-by-step what happens when exiting plus.

	popl %ebp
	      Stack
	|               |
	+---------------+
	| ra in startup |  <----- esp once entering main
	+---------------+
	|    old ebp    |
	+---------------+
	|      10       |
	+---------------+
	|      37       |
	+---------------+
	|  ra in main   |  <----- esp once entering plus
	+---------------+
	|               |
	+---------------+
	|               |
	+---------------+
	|               |

	ret (in plus)
	addl $8, %esp

	      Stack
	|               |
	+---------------+
	| ra in startup |  <----- esp once entering main
	+---------------+
	|    old ebp    |
	+---------------+
	|      10       |  <----- esp: freeing up space from here
	+---------------+              and below.
	|      37       |
	+---------------+
	|  ra in main   |  
	+---------------+
	|               |
	+---------------+
	|               |
	+---------------+
	|               |

	leave (in main)
		- the esp <- ebp protion of leave
	      Stack
	|               |
	+---------------+
	| ra in startup |  <----- esp once entering main
	+---------------+
	|    old ebp    |  <----- esp
	+---------------+
	|      10       |
	+---------------+ 
	|      37       |
	+---------------+
	|  ra in main   |  
	+---------------+
	|               |
	+---------------+
	|               |
	+---------------+
	|               |

	leave (in main)
		- the pop ebp protion of leave
	      Stack
	|               |
	+---------------+
	| ra in startup |  <----- esp
	+---------------+
	|    old ebp    |
	+---------------+
	|      10       |
	+---------------+ 
	|      37       |
	+---------------+
	|  ra in main   |  
	+---------------+
	|               |
	+---------------+
	|               |
	+---------------+
	|               |

	How a function uses local or global variables is explained below.
------------------------------------------------------------------------
2) Local vs Global Variables

a. Local Variables



b. Global Variables
	In x86, we can declare static data regions. Data declarations should
	be preceded by the .data directive. Let's say we have a C program
	like the following.

	<donothing.c>
		int a = 37;
		int b = 10;
		int main(void) {
			return a + b;
		}

	Then the donothing.s file will look like this.
	We will just show the first few lines of the code where the
	variables a and b are defined.

	<donothing.s>
			.globl a
			.data
			.align 4
		a:
			.long 37
			.globl b
			.align 4
		b:
			.long 10

	Notice how the names a and b first show up with the .globl directive.
	Then, after the .data directive we align with 4 (just an x86 thing)
	and declare the data a: and b:.

------------------------------------------------------------------------
3) Arrays


========================================================================
Problem 2: Out of Sorts
========================================================================


========================================================================
Problem 3: It's a cat Jim...
========================================================================


========================================================================
Problem 4: ...but now as we know it!
========================================================================




========================================================================
<End of File>